# 宿題3
> 直近にアクセスされた上位X個のページをキャッシュしたい  
> _O(1)_ での管理を実現する方法について考える

<br />

### 考え方
- 保存してあるキャッシュにO(1)でアクセス -> ハッシュを利用する?
- 時系列をO(1)で管理したい -> リストで実装できそう
  - 連結リストだと先頭に移動させるのが大変
  - 双方向リストを利用すれば移動もO(1)でできる?

<br />

***
### データ構造
#### ハッシュ
- <URL,Webページ,*node> を保持

#### 双方向リスト
```
struct node{
    string url; //自身のURL
    node* prev; //初期値はNULL
    node* now;  //自身のポインタ
    node* next; //初期値はNULL
};
```
#### その他保持するデータ
- 双方向リストの先頭ポインタ　 　: node* front
- 双方向リストの最後尾ポインタ　 : node* end
- キャッシュの大きさ 　:　X

<br />

### 以下に例を示す
***
キャッシュの大きさを3とする  
データXを<x.com, ページX, node* x>とする

1. データA,データB,データCがこの順で読み込まれたとする。  
   キャッシュ内にはデータA,データB,データCが存在  
この時、双方向リストは
(先頭) A -> B -> C (後方)
2. データBが読み込まれたとする  
     　　-> キャッシュ内にBが存在 
    - ハッシュテーブルの変更 : 必要なし
    - 双方向リスト内のデータ付け替え  
        Bへのアクセス : O(1)
        ```
        //B.next==NULLの時:何もしない
        if(B.next!=NULL){
            if(B.prev==NULL){B.next.prev=NULL;}
            else{
                B.prev.next = B.next.prev;
                B.next.prev = B.prev.next;
            }
            B.prev = end;
            B.prev.next = B.now;
            B.next = NULL;
            end = B.now;
        }
        ```
    キャッシュ内にはデータA,データB,データCが存在  
    この時、双方向リストは (先頭) A -> C -> B (後方)

<br />

3. データDが読み込まれたとする  
     　　-> キャッシュ内にDが存在 
    - ハッシュテーブルに<d.com,ページD,node* D>を追加 : O(1)
    - 双方向リストにDを追加 : O(1)
        ```
        end.next = D;
        D.prev = end;
        end = D;
        ```
    - node* frontにアクセス : O(1)  
      - ハッシュテーブルからfront.stringに該当するものを削除 : O(1)  
       - 双方向リストの先頭を更新 : O(1)
        ```
        front = front.next;
        front.prev = NULL;//frontは更新済み
        ```


    キャッシュ内にはデータD,データB,データCが存在  
    この時、双方向リストは (先頭) C -> B -> D (後方)

<br />

***
### 問題点
- メモリの使用量が多い
- ポインタの動きが不安なのでこれ通りのコードだと動かないかもしれない 
        